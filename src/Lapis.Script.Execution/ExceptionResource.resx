<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessorStatementsExpected" xml:space="preserve">
    <value>Expected statements of the property accessor or indexer.</value>
  </data>
  <data name="ArrayAssignNotMatch" xml:space="preserve">
    <value>Patterns of the l-value and r-value don't match.</value>
  </data>
  <data name="ArrayIndexMustBePosInteger" xml:space="preserve">
    <value>Array index must be a non-negative integer.</value>
  </data>
  <data name="ArrayLengthMustBePosInteger" xml:space="preserve">
    <value>The length of array must be a non-negative integer.</value>
  </data>
  <data name="AutoPropertyMustHasGetSet" xml:space="preserve">
    <value>Auto-implemented properties must define the get and set accessors.</value>
  </data>
  <data name="BreakMustBeInLoopOrSwitch" xml:space="preserve">
    <value>No enclosing loop out of which to break.</value>
  </data>
  <data name="CannotAssignClass" xml:space="preserve">
    <value>{0} is a type that cannot be assigned.</value>
  </data>
  <data name="_CannotAssignConst" xml:space="preserve">
    <value>{0} is a constant that cannot be assigned a value.</value>
  </data>
  <data name="CannotAssignFunction" xml:space="preserve">
    <value>{0} is a function that cannot be assigned a value.</value>
  </data>
  <data name="CannotAssignMethod" xml:space="preserve">
    <value>{0} is a method that cannot be assigned a value.</value>
  </data>
  <data name="CannotBeStatic" xml:space="preserve">
    <value>Static modifier here is invalid.</value>
  </data>
  <data name="CannotUseBothGetSetModifier" xml:space="preserve">
    <value>The modifier is permitted on one only of the two accessors.</value>
  </data>
  <data name="CannotUseGetSetModifier" xml:space="preserve">
    <value>Accessor modifiers can be used only if the property or indexer has both set and get accessors.</value>
  </data>
  <data name="ClassExpectedForNewExpression" xml:space="preserve">
    <value>New operator must be applied to type.</value>
  </data>
  <data name="ConstructorMustBePublic" xml:space="preserve">
    <value>Constructors must be public.</value>
  </data>
  <data name="ContinueMustBeInLoop" xml:space="preserve">
    <value>No enclosing loop out of which to continue.</value>
  </data>
  <data name="ClassAlreadyExists" xml:space="preserve">
    <value>Identifier {0} has been declared as type.</value>
  </data>
  <data name="FunctionAlreadyExists" xml:space="preserve">
    <value>Identifier {0} has been declared as function.</value>
  </data>
  <data name="InvalidStatememt" xml:space="preserve">
    <value>Invalid statement.</value>
  </data>
  <data name="VariableAlreadyExists" xml:space="preserve">
    <value>Identifier {0} has been declared as variable.</value>
  </data>
  <data name="Expected" xml:space="preserve">
    <value>Expected {0}.</value>
  </data>
  <data name="ExpressionExpected" xml:space="preserve">
    <value>Expected an expression.</value>
  </data>
  <data name="FunctionExpectedToInvoke" xml:space="preserve">
    <value>Only functions or methods can be invoked.</value>
  </data>
  <data name="GetSetModifierMoreStrictThanProperty" xml:space="preserve">
    <value>The accessibility level on the accessor must be more restrictive than the accessibility level on the property or indexer itself.</value>
  </data>
  <data name="IdentifierExpected" xml:space="preserve">
    <value>Expected an identifier.</value>
  </data>
  <data name="IndexerAlreadyExists" xml:space="preserve">
    <value>Indexer already exists.</value>
  </data>
  <data name="IndexerIsReadonly" xml:space="preserve">
    <value>The indexer cannot be assigned a value, because it is read-only.</value>
  </data>
  <data name="IndexerIsWriteonly" xml:space="preserve">
    <value>The indexer is write-only.</value>
  </data>
  <data name="IndexerNotSupported" xml:space="preserve">
    <value>The object does not support an indexer.</value>
  </data>
  <data name="InvalidIdentifier" xml:space="preserve">
    <value>Invalid identifier.</value>
  </data>
  <data name="InvalidOperator" xml:space="preserve">
    <value>Invalid operator.</value>
  </data>
  <data name="LabelAlreadyExists" xml:space="preserve">
    <value>Label {0} already exists.</value>
  </data>
  <data name="LabelNotFound" xml:space="preserve">
    <value>Cannot find label {0} within the scope of goto statement。</value>
  </data>
  <data name="LeftExpressionExpected" xml:space="preserve">
    <value>L-value can only be a variable, property or indexer.</value>
  </data>
  <data name="MemberAlreadyExists" xml:space="preserve">
    <value>Member {0} already exists.</value>
  </data>
  <data name="MemberExpected" xml:space="preserve">
    <value>Expected a property or method.</value>
  </data>
  <data name="MemberNotFound" xml:space="preserve">
    <value>The object does not have a member named {0}.</value>
  </data>
  <data name="MultipleConstructors" xml:space="preserve">
    <value>Multiple constructors are not allowed.</value>
  </data>
  <data name="NullReference" xml:space="preserve">
    <value>Object reference not set to an instance of an object.</value>
  </data>
  <data name="OperatorNotSupported" xml:space="preserve">
    <value>Operator {0} cannot be applied to the operands.</value>
  </data>
  <data name="ParemetersExpected" xml:space="preserve">
    <value>Expected parameters of the function or method.</value>
  </data>
  <data name="ParemetersNotMatch" xml:space="preserve">
    <value>The function, method or indexer does not accept the parameters.</value>
  </data>
  <data name="PropertyIsReadonly" xml:space="preserve">
    <value>Property {0} cannot be assigned a value, because it is read-only.</value>
  </data>
  <data name="PropertyIsWriteonly" xml:space="preserve">
    <value>Property {0} is write-only.</value>
  </data>
  <data name="ReturnMustBeInFunction" xml:space="preserve">
    <value>Return statements must be in the body of the function.</value>
  </data>
  <data name="StatementExpected" xml:space="preserve">
    <value>Expected a statement.</value>
  </data>
  <data name="StatementsExpected" xml:space="preserve">
    <value>Expected statements of the function or method.</value>
  </data>
  <data name="SuperMustBeInExtendedClass" xml:space="preserve">
    <value>Super reference can only appear in the instance methods of derived class.</value>
  </data>
  <data name="ThisMustBeInInstanceMethod" xml:space="preserve">
    <value>This reference can only appear in the instance methods.</value>
  </data>
  <data name="TypeExpected" xml:space="preserve">
    <value>Expected a type reference.</value>
  </data>
  <data name="Undefined" xml:space="preserve">
    <value>{0} is undefined.</value>
  </data>
  <data name="UnrecognizedEscapeCharacter" xml:space="preserve">
    <value>Unrecognized escape character.</value>
  </data>
  <data name="_UnterminatedString" xml:space="preserve">
    <value>Unterminated string.</value>
  </data>
  <data name="AutoParameterNameExist" xml:space="preserve">
    <value>{0} conflicts with the automatically-generated parameters.</value>
  </data>
  <data name="_CannotReturnWithValue" xml:space="preserve">
    <value>The functions or methods cannot have a return value.</value>
  </data>
  <data name="InvalidExpression" xml:space="preserve">
    <value>Invalid expression.</value>
  </data>
  <data name="InvalidSuper" xml:space="preserve">
    <value>Super reference can only be used to access members of the super class, or call the constructor of super class.</value>
  </data>
  <data name="_MustReturnWithValue" xml:space="preserve">
    <value>Expected a return value.</value>
  </data>
  <data name="OptionalParameterMustBeAtLast" xml:space="preserve">
    <value>Optional parameters must appear after all required parameters.</value>
  </data>
  <data name="ParameterAlreadyExists" xml:space="preserve">
    <value>Parameter {0} already exists.</value>
  </data>
  <data name="SuperInvoke" xml:space="preserve">
    <value>Super call must be the first statement in the constructor.</value>
  </data>
  <data name="CannotConvertToBoolean" xml:space="preserve">
    <value>The object cannot be converted to Boolean.</value>
  </data>
  <data name="ConstructorParemetersNotMatch" xml:space="preserve">
    <value>Constructor {0} does not accept the parameters.</value>
  </data>
  <data name="NotInheritable" xml:space="preserve">
    <value>The specified class cannot be inherited.</value>
  </data>
</root>